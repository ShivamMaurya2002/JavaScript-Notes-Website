<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Error Handling in JavaScript</title>
    <style>
        body {
              line-height: 1.3;
              font-size: 16px;
              margin: 20px;
              background-color: #eaedf0;
          }
          pre {
              background-color: #dbdfe3;
              padding: 15px;
              border-radius: 5px;
              overflow-x: auto;
          }
          code {
             
              color: #000000;
          }
          h1, h2 {
              color: #343a40;
          }
          h3 {
              color: #495057;
          }
          .example {
              color: #f52222;
          }
      </style>
</head>
<body>
    <h1>Error Handling in JavaScript</h1>
    <p>
        JavaScript provides multiple ways to handle errors, allowing developers to manage exceptions effectively and maintain code stability. Below are common approaches to error handling:
    </p>

    <h2>1. Try-Catch Block</h2>
    <p>
        The <code>try-catch</code> block is used to catch exceptions and handle errors gracefully.
    </p>
    <pre><code>
try {
    let result = 10 / 0;
    console.log(result); // Output: Infinity
    throw new Error("Custom Error Message");
} catch (error) {
    console.error("Error caught:", error.message);
} finally {
    console.log("Execution continues...");
}
    </code></pre>
    <p class="example">Output:  
    Error caught: Custom Error Message  
    Execution continues...</p>

    <h2>2. Using Throw</h2>
    <p>
        The <code>throw</code> statement is used to manually throw exceptions.
    </p>
    <pre><code>
function divide(a, b) {
    if (b === 0) {
        throw new Error("Cannot divide by zero");
    }
    return a / b;
}

try {
    console.log(divide(10, 0));
} catch (error) {
    console.error(error.message);
}
    </code></pre>
    <p class="example">Output: Cannot divide by zero</p>

    <h2>3. Error Object</h2>
    <p>
        The <code>Error</code> object provides additional information about errors.
    </p>
    <pre><code>
try {
    JSON.parse("{ invalid JSON }");
} catch (error) {
    console.error("Error Name:", error.name); // SyntaxError
    console.error("Error Message:", error.message); // Unexpected token i in JSON
}
    </code></pre>
    <p class="example">Output:  
    Error Name: SyntaxError  
    Error Message: Unexpected token i in JSON</p>

    <h2>4. Promises with .catch</h2>
    <p>
        Promises handle asynchronous errors using the <code>.catch</code> method.
    </p>
    <pre><code>
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => reject("Data fetch failed"), 1000);
});

fetchData
    .then(data => console.log(data))
    .catch(error => console.error("Error:", error));
    </code></pre>
    <p class="example">Output (after 1 second): Error: Data fetch failed</p>

    <h2>5. Async/Await with Try-Catch</h2>
    <p>
        When using <code>async/await</code>, errors are caught using a <code>try-catch</code> block.
    </p>
    <pre><code>
async function fetchData() {
    try {
        let response = await Promise.reject("Data fetch failed");
        console.log(response);
    } catch (error) {
        console.error("Error:", error);
    }
}

fetchData();
    </code></pre>
    <p class="example">Output: Error: Data fetch failed</p>

    <h2>Conclusion</h2>
    <p>
        Proper error handling ensures that your application is resilient and provides meaningful feedback during failures. Combining techniques like <code>try-catch</code> and Promise error handling can significantly enhance code reliability.
    </p>
</body>
</html>
